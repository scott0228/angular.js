/* global beforeEach, afterEach, describe, it, expect, inject, module */

'use strict';

describe('CVE-2023-26117', function() {

  beforeEach(function() {
    this.originalTimeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;
    jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000; // 10 second timeout
  });

  afterEach(function() {
    jasmine.DEFAULT_TIMEOUT_INTERVAL = this.originalTimeout;
  });

  beforeEach(module('ngResource'));

  it('should not cause ReDoS when processing URLs with many trailing slashes', inject(function($resource) {
    // Create a URL with many trailing slashes that would cause ReDoS
    // The vulnerability occurs with the /\/+$/ regex when processing URLs with many trailing slashes
    var baseUrl = 'http://example.com/api/users';
    var maliciousUrl = baseUrl + 'foo' + '/'.repeat(30) + 'bar'; // Pattern similar to CVE demo

    var startTime = Date.now();

    try {
      // This should trigger the vulnerable regex during URL processing
      var resource = $resource(maliciousUrl);
      var query = resource.query();

      // Cancel the request immediately since we're testing regex performance, not HTTP
      if (query.$cancelRequest) {
        query.$cancelRequest();
      }
    } catch (e) {
      // Catch any errors but still measure time
    }

    var endTime = Date.now();
    var duration = endTime - startTime;

    // The operation should complete quickly (under 1 second)
    expect(duration).toBeLessThan(1000);
  }));

  it('should handle URLs with various trailing slash patterns without ReDoS', inject(function($resource) {
    var testUrls = [
      'http://example.com/api',
      'http://example.com/api/',
      'http://example.com/api' + '/'.repeat(25),
      'http://example.com/api' + '/'.repeat(30) + 'resource',
      'http://example.com/api' + '/'.repeat(20) + '?param=value'
    ];

    testUrls.forEach(function(url, index) {
      var startTime = Date.now();

      var resource = $resource(url);
      var query = resource.query();

      if (query.$cancelRequest) {
        query.$cancelRequest();
      }

      var endTime = Date.now();
      var duration = endTime - startTime;

      expect(duration).toBeLessThan(500); // Should be very fast
    });
  }));

  it('should properly strip trailing slashes functionality without ReDoS', inject(function($resource, $httpBackend) {
    // Test that the fix still preserves the trailing slash stripping functionality
    var baseUrl = 'http://example.com/api/users';
    var urlWithSlashes = baseUrl + '/'.repeat(10);

    // Mock the HTTP request to see what URL is actually used
    $httpBackend.expect('GET', baseUrl).respond(200, []);
    var resource = $resource(urlWithSlashes);
    var startTime = Date.now();

    resource.query();

    var endTime = Date.now();
    var duration = endTime - startTime;

    // Should be fast and should have stripped the trailing slashes
    expect(duration).toBeLessThan(500);

    $httpBackend.flush();
  }));

  it('should handle edge cases without ReDoS', inject(function($resource) {
    var edgeCases = [
      'http://example.com/',           // Single trailing slash
      'http://example.com' + '/'.repeat(50), // Many trailing slashes
      'http://example.com/api' + '/'.repeat(25) + '/', // Mixed pattern
      'http://example.com/api' + '/'.repeat(30) + 'endpoint' // Slashes followed by non-slash
    ];

    edgeCases.forEach(function(url) {
      var startTime = Date.now();

      var resource = $resource(url);
      var query = resource.query();

      if (query.$cancelRequest) {
        query.$cancelRequest();
      }

      var endTime = Date.now();
      var duration = endTime - startTime;

      expect(duration).toBeLessThan(500);
    });
  }));
});
