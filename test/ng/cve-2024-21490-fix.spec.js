/**
 * Test to demonstrate CVE-2024-21490 fix
 * 
 * This test shows that the ReDoS vulnerability in sanitizeSrcset has been fixed.
 * The original vulnerable regex pattern could cause catastrophic backtracking
 * with carefully crafted input, leading to denial of service.
 */

'use strict';

describe('CVE-2024-21490 fix', function() {
  var element, $rootScope, $compile;

  beforeEach(module('ng'));
  
  beforeEach(inject(function(_$rootScope_, _$compile_) {
    $rootScope = _$rootScope_;
    $compile = _$compile_;
  }));

  afterEach(function() {
    if (element) {
      dealoc(element);
    }
  });

  it('should handle normal srcset values efficiently', inject(function() {
    var normalSrcsets = [
      'image.jpg 1x',
      'image1.jpg 1x, image2.jpg 2x',
      'image.jpg 100w, image2.jpg 200w',
      'small.jpg 1x, medium.jpg 2x, large.jpg 3x'
    ];

    normalSrcsets.forEach(function(srcset) {
      element = $compile('<img>')($rootScope);
      var start = performance.now();
      $rootScope.attr = element.scope().$new();
      $rootScope.attr.$$element = element;
      $rootScope.attr.$set('srcset', srcset);
      var end = performance.now();
      
      expect(end - start).toBeLessThan(10); // Should complete in less than 10ms
      expect(element.attr('srcset')).toBeDefined();
      dealoc(element);
      element = null;
    });
  }));

  it('should resist ReDoS attack patterns', inject(function() {
    // These patterns would have caused catastrophic backtracking in the vulnerable version
    var attackPatterns = [
      // Patterns with excessive spaces that could trigger ReDoS
      'img.jpg' + ' '.repeat(100) + '1x',
      'img.jpg' + ' '.repeat(200) + '2x,' + ' '.repeat(100) + 'img2.jpg',
      'a' + ' '.repeat(50) + 'x' + ' '.repeat(50) + ','
    ];

    attackPatterns.forEach(function(pattern) {
      element = $compile('<img>')($rootScope);
      var start = performance.now();
      
      $rootScope.attr = element.scope().$new();
      $rootScope.attr.$$element = element;
      $rootScope.attr.$set('srcset', pattern);
      
      var end = performance.now();
      var timeTaken = end - start;
      
      // Should complete quickly even with attack patterns
      expect(timeTaken).toBeLessThan(50); // Should complete in less than 50ms
      expect(element.attr('srcset')).toBeDefined();
      
      dealoc(element);
      element = null;
    });
  }));

  it('should correctly parse complex srcset values', inject(function() {
    var complexSrcset = 'img1.jpg 1x, img2.jpg 2x, img3.jpg 3x, img4.jpg 300w, img5.jpg 600w';
    
    element = $compile('<img>')($rootScope);
    $rootScope.attr = element.scope().$new();
    $rootScope.attr.$$element = element;
    $rootScope.attr.$set('srcset', complexSrcset);
    
    var result = element.attr('srcset');
    expect(result).toContain('img1.jpg 1x');
    expect(result).toContain('img2.jpg 2x');
    expect(result).toContain('img3.jpg 3x');
    expect(result).toContain('img4.jpg 300w');
    expect(result).toContain('img5.jpg 600w');
  }));

  it('should handle edge cases without hanging', inject(function() {
    var edgeCases = [
      '',           // empty string
      ' ',          // single space
      ',',          // single comma
      '  ,  ',      // spaces around comma
      'img.jpg',    // no descriptor
      'img.jpg ',   // trailing space
      ' img.jpg',   // leading space
      'img.jpg,',   // trailing comma
      ',img.jpg',   // leading comma
    ];

    edgeCases.forEach(function(edgeCase) {
      element = $compile('<img>')($rootScope);
      var start = performance.now();
      
      $rootScope.attr = element.scope().$new();
      $rootScope.attr.$$element = element;
      $rootScope.attr.$set('srcset', edgeCase);
      
      var end = performance.now();
      
      expect(end - start).toBeLessThan(10); // Should complete quickly
      // Should not throw or hang
      
      dealoc(element);
      element = null;
    });
  }));
});
