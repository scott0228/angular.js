/* global beforeEach, afterEach, describe, it, expect */

'use strict';

describe('CVE-2023-26116', function() {

  beforeEach(function() {
    this.originalTimeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;
    jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000; // 10 second timeout
  });

  afterEach(function() {
    jasmine.DEFAULT_TIMEOUT_INTERVAL = this.originalTimeout;
  });

  it('should not cause ReDoS when copying RegExp with catastrophic backtracking pattern', function() {
    // Create a RegExp that would cause ReDoS due to the vulnerable regex /[^/]*$/
    // The vulnerable pattern occurs when a RegExp source contains many characters followed by '/'
    var maliciousSource = 'a'.repeat(30) + '/';
    var maliciousRegex = new RegExp(maliciousSource);

    var startTime = Date.now();
    var copiedRegex = angular.copy(maliciousRegex);
    var endTime = Date.now();
    var duration = endTime - startTime;

    // The operation should complete quickly (under 1 second)
    expect(duration).toBeLessThan(1000);
    expect(copiedRegex).toEqual(maliciousRegex);
    // Note: RegExp source escapes special characters, so '/' becomes '\/'
    expect(copiedRegex.source).toBe(maliciousRegex.source);
  });

  it('should handle RegExp with flags correctly without ReDoS', function() {
    // Test with various flags to ensure the fix works correctly
    var patterns = [
      { source: 'test', flags: 'g' },
      { source: 'a'.repeat(25) + '/', flags: 'gi' },
      { source: 'complex' + 'x'.repeat(20) + '/', flags: 'gim' }
    ];

    patterns.forEach(function(pattern) {
      var originalRegex = new RegExp(pattern.source, pattern.flags);

      var startTime = Date.now();
      var copiedRegex = angular.copy(originalRegex);
      var endTime = Date.now();
      var duration = endTime - startTime;

      expect(duration).toBeLessThan(500); // Should be very fast
      expect(copiedRegex.source).toBe(originalRegex.source);
      expect(copiedRegex.flags).toBe(originalRegex.flags);
      expect(copiedRegex.global).toBe(originalRegex.global);
      expect(copiedRegex.ignoreCase).toBe(originalRegex.ignoreCase);
      expect(copiedRegex.multiline).toBe(originalRegex.multiline);
    });
  });

  it('should handle edge cases without ReDoS', function() {
    var edgeCases = [
      new RegExp(''),                    // Empty pattern
      new RegExp('/'),                   // Single slash
      new RegExp('//'),                  // Double slash
      new RegExp('a'.repeat(50)),        // Long pattern without slash
      new RegExp('a'.repeat(30) + '/$') // Pattern ending with /$
    ];

    edgeCases.forEach(function(regex, index) {
      var startTime = Date.now();
      var copied = angular.copy(regex);
      var endTime = Date.now();
      var duration = endTime - startTime;

      expect(duration).toBeLessThan(500);
      expect(copied.source).toBe(regex.source);
    });
  });
});
